                         +-----------------+
                         |    COMP 7035    |
                         |   Assigment 1   |
                         |      Report     |
                         +-----------------+

---- GROUP ----

Ashakan Zahedanaraki <ashkanzahde@gmail.com>
Gagan Bahugun <gbahugun@my.bcit.ca>

---- PRELIMINARIES ----

None.

                              Timer_Sleep
                                 ====

---- DATA STRUCTURES ----

Added to struct thread in thread.h:

    /* The tick when the thread should wake up. */
    int64_t wake_up_tick;

Added to thread.c:

    /* List of processes in THREAD_SLEEP state, that is, processes
       that are waiting for a certain time to elapse before they
       can transition to ready or running state. */
    static struct list sleep_list;

---- ALGORITHMS ----

timer_sleep() - First it checks if ticks are less than or equal to zero and immediately returns if they are.
Then it sets the wake_up_tick of the current thread to when the thread should wake up.
Finally, it calls thread_sleep to put the current thread to sleep.

timer_interrupt() - First it increases ticks by one.
Then it calls thread_tick to update thread statistics.
Finally, it calls thread_wake to wake up any threads that are ready to wake up.

thread_asleep() - Switches the status of the current thread to THREAD_ASLEEP and then calls the scheduler.

thread_sleep() - If the current thread isn't the idle thread then add it to the sleep_list and put it to sleep.

thread_wake() - Loop through all the threads in sleep_list and check if they should wake up. If the first thread
in the list shouldn't wake up then break the loop. Otherwise, remove the thread from the sleep_list, add the
thread to the ready_list and switch the thread's status to THREAD_READY.

earlier_wake_up() - Comparator that compares the wake_up_tick of two threads.
Returns true if the wake_up_tick of the first thread is less than the wake_up_tick of the second thread.
Otherwise, returns false.


---- SYNCHRONIZATION ----

>> Consider parent thread P with child thread C.  How do you ensure
>> proper synchronization and avoid race conditions when P calls wait(C)
>> before C exits?  After C exits?  How do you ensure that all resources
>> are freed in each case?  How about when P terminates without waiting,
>> before C exits?  After C exits?  Are there any special cases?

C waits in thread_exit() for P to die before it finishes its own
exit, using the can_die semaphore "down"ed by C and "up"ed by P as
it exits.  Regardless of whether whether C has terminated, there
is no race on wait(C), because C waits for P's permission before
it frees itself.

Regardless of whether P waits for C, P still "up"s C's can_die
semaphore when P dies, so C will always be freed.  (However,
freeing C's resources is delayed until P's death.)

The initial thread is a special case because it has no parent to
wait for it or to "up" its can_die semaphore.  Therefore, its
can_die semaphore is initialized to 1.

---- RATIONALE ----

>> Critique your design, pointing out advantages and disadvantages in
>> your design choices.

This design has the advantage of simplicity.  Encapsulating most
of the synchronization logic into a new "latch" structure
abstracts what little complexity there is into a separate layer,
making the design easier to reason about.  Also, all the new data
members are in `struct thread', with no need for any extra dynamic
allocation, etc., that would require extra management code.

On the other hand, this design is wasteful in that a child thread
cannot free itself before its parent has terminated.  A parent
thread that creates a large number of short-lived child threads
could unnecessarily exhaust kernel memory.  This is probably
acceptable for implementing kernel threads, but it may be a bad
idea for use with user processes because of the larger number of
resources that user processes tend to own.